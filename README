## Questão 01

**Pattern Usado:** **Strategy (Estratégia)**

**Justificativa:**

O problema exigia que diferentes algoritmos de cálculo de risco (VaR, Expected Shortfall, etc.) fossem **intercambiáveis em tempo de execução**.

O padrão **Strategy** foi escolhido por ser sua definição exata: ele permite definir uma família de algoritmos (as `RiskAlgorithm`), encapsular cada um em uma classe separada e torná-los intercambiáveis.

* **Polimorfismo:** A classe de contexto (`RiskAnalysisProcessor`) opera apenas contra a interface `RiskAlgorithm`, sem nunca conhecer a implementação concreta.
* **SOLID (SRP):** O processador tem a única responsabilidade de *orquestrar* a análise, enquanto cada classe de algoritmo (ex: `VaRAlgorithm`) tem a única responsabilidade de *implementar esse cálculo específico*.
* **Atende aos Requisitos:** O cliente pode trocar o algoritmo dinamicamente (via `setAlgorithm()`) sem qualquer `if/else` ou `switch` no código do processador, o que também adere ao princípio Aberto/Fechado (OCP).

---

## Questão 02

**Pattern Usado:** **Adapter (Adaptador)**

**Justificativa:**

O problema descreve um cenário clássico de **incompatibilidade de interfaces**. Tínhamos uma interface moderna (`ProcessadorTransacoes`) que precisava se comunicar com uma interface legada (`SistemaBancarioLegado`) que esperava um `HashMap` e usava códigos de moeda.

O padrão **Adapter** foi escolhido para atuar como o "tradutor" ou "intermediário" entre esses dois mundos.

* **Tradução de Ida e Volta:** A classe `LegadoAdapter` implementa a interface moderna (o "Target"), mas internamente "embrulha" (wraps) o sistema legado (o "Adaptee").
* **Atende aos Requisitos:**
    1.  **Tradução (Ida):** O método `autorizar()` do adaptador converte os parâmetros simples (cartão, valor, moeda) no `HashMap` complexo que o legado espera, incluindo a tradução de "BRL" para `3` e a adição de campos obrigatórios.
    2.  **Bidirecionalidade (Volta):** O adaptador também converte a `LegacyResponse` (com status code) em uma `ModernResponse` (com booleano de sucesso), cumprindo o requisito de ser bidirecional.
* **SOLID (SRP):** A responsabilidade do adaptador é unicamente a *tradução*. O cliente moderno permanece limpo e ignorante da complexidade do legado.

---

## Questão 03

**Patterns Usados:**
1.  **State (Estado)** - (Principal)
2.  **Decorator (Decorador)** - (Auxiliar)

**Justificativa:**

O problema descrevia um sistema (`UsinaNuclear`) cujo comportamento mudava drasticamente com base em seu estado interno (DESLIGADA, NORMAL, AMARELO, etc.), com regras complexas de transição.

1.  **State Pattern:** Foi escolhido para gerenciar o fluxo principal. Em vez de um `switch` ou `if/else` gigante na classe `UsinaNuclear` (o que violaria SRP e OCP), encapsulamos o *comportamento* de cada estado em sua própria classe (ex: `OperacaoNormalState`, `AlertaAmareloState`).
    * **Polimorfismo:** A `UsinaNuclear` (Contexto) apenas delega a ação (ex: `monitorar()`) para seu objeto de estado atual (`UsinaState`).
    * **Atende aos Requisitos:** As próprias classes de estado são responsáveis por validar as transições (ex: checar `temperatura > 300`) e informar o Contexto para qual novo estado ele deve mudar. Isso manteve o Contexto limpo e a lógica de transição isolada.

2.  **Decorator Pattern:** Foi escolhido para resolver o requisito do **"modo manutenção"**. Este modo não é um estado linear no fluxo (como AMARELO -> VERMELHO), but sim uma "camada" que *sobreescreve temporariamente* o comportamento de qualquer estado.
    * **Atende aos Requisitos:** O `ManutencaoStateDecorator` implementa a mesma interface `UsinaState`. Ele "embrulha" o estado atual (ex: `AlertaVermelhoState`). Quando a usina entra em manutenção, todas as chamadas (como `monitorar()`) são interceptadas pelo Decorator, que executa seu próprio comportamento (ex: "Monitoramento suspenso") em vez de repassar a chamada para o estado embrulhado.

---

## Questão 04

**Patterns Usados:**
1.  **Chain of Responsibility (Cadeia de Responsabilidade)** - (Principal)
2.  **Context Object** (Auxiliar)
3.  **Template Method** (Auxiliar)

**Justificativa:**

O problema exigia um pipeline de validações em série, onde um documento passava por múltiplos validadores (XML, Certificado, Fiscal, DB, SEFAZ). Além disso, havia regras complexas como interrupção (circuit breaker), execução condicional e rollback.

1.  **Chain of Responsibility (CoR):** Foi o padrão principal para criar a cadeia. Cada validador (`Validator`) é um "elo" que recebe o documento, processa-o e (se tudo estiver OK) o passa para o próximo elo. Isso desacoplou os validadores uns dos outros e o cliente da implementação da cadeia.

2.  **Context Object:** Um CoR simples não era suficiente. Criamos um `ValidationContext` para ser passado *através* da cadeia.
    * **Atende aos Requisitos:** Este objeto carregou o estado compartilhado, permitindo-nos implementar:
        * **Circuit Breaker:** O contexto continha um contador (`getFailureCount()`) que cada validador verificava.
        * **Rollback:** O contexto mantinha uma *Pilha* (`Stack`) dos validadores que já haviam executado, para que pudéssemos chamar o `rollback()` na ordem inversa (LIFO) em caso de falha.

3.  **Template Method:** Para evitar duplicar a lógica de *gerenciamento da cadeia* (checar circuit breaker, checar "skip", chamar o próximo, tratar timeout) em *todos* os validadores, usamos um `AbstractValidator`.
    * **Atende aos Requisitos:** Esta classe abstrata forneceu o método `validate()` (o *Template Method*) que cuidava dessa lógica de orquestração. As classes concretas (ex: `XmlSchemaValidator`) só precisavam implementar um método (`runValidation()`) com sua lógica de negócio específica. Os validadores condicionais (Fiscal e SEFAZ) apenas sobrescreveram o "hook" `shouldSkip()`.